---
title: 脱离古法手工编程有感
tags: ["AI", "生活"]
key: blog-2025-08-15
---

几个月前，我开始尝试用 AI 辅助编程工具，脱离了纯古法手工编程的旧况，下面是我的一些阶段性体会和感受。

> 本文部分内容由 AI 润色

## 背景

起初我对 AI 编程工具颇有抵触。一方面，Xcode 天然不支持这些工具，要绕过它使用会增加很多麻烦，感觉投入产出比不高，有需要时我更愿意直接问 ChatGPT，然后复制粘贴到 Xcode；另一方面，当时的 AI 代码质量确实一般，免费版 ChatGPT 生成的 Swift 代码勉强能用，API 调用更是问题百出，我也没深究付费模型是否会有更好表现。

转机出现在几个月前。业务需求让我转向 VSCode 开发 React Native，这是个全新领域。对于简单的代码维护，照猫画虎确实能应付🐯，我也很快上手了 RN 的基础开发。但一旦遇到复杂需求或棘手 bug，就彻底卡壳了。即使学习了相关文档和教程，该解决不了的还是解决不了，经常对着一个 bug 坐牢一整天。

恰在此时，Github Copilot 开放了免费使用🆓。作为当时（可能现在也是）唯一能在 Xcode 中使用的 AI 辅助工具，我立刻下载体验。虽然当时只有代码补全功能，但效率已经比在 Chat 工具中提问高出太多。这让我意识到合适的工具能带来指数级的效率提升，于是果断充值，在 VSCode 中也配置了 Copilot。从那以后效率大幅提升，经常感慨"它"写得比我还好。

自此之后我写代码很大部分就依仗 AI 了，虽然 AI 写的代码不完全是开箱即用，但是仍然是优点远大于缺点的。

## 优点和缺点

### 模版代码高手

AI 在处理模版代码方面非常好用。举个例子，当我写了一个枚举，想在某处判断枚举值时，只要打出 switch，所有的 case 就瞬间被补全了，甚至还实现了部分 case 的具体内容——这种体验在原生 Xcode 里根本不存在。更厉害的是写通用模版函数的时候，比如增删查改、简单的单任务队列等等。只要你的类名、变量名命名得当，基本就是你写个开头，AI 就能帮你实现剩下的所有内容，而且出错概率可能比你手写还要低。属于是赛博版的"你一撅屁股他就知道你要放什么屁"🌬️。

### 边 vibe coding 边学

以前写代码遇到不熟悉的地方，要么上网查资料借鉴别人的经验，要么依照自己以往的实现方式照葫芦画瓢。这是传统编程的常规流程，但 vibe coding 的出现让这个过程变得高效得多。当 AI 生成代码后，我经常发现它的实现思路和我完全不同，有些方法我根本不知道还能这样写，或者压根没接触过某些框架和模式。这种边写边学的模式让我在 vibe coding 的同时也在持续学习。拿写 RN 代码来说，我是个彻头彻尾的新手，经常写出一些"能跑但不够好"的代码。这时 AI 不仅会帮我收拾残局，还会把更优雅的代码实现直接甩在我面前🩴，让我学到不少东西。

### 蓝(?)海市场的迭代速度

不知道现在 AI 编程工具市场还算不算蓝海，但这段使用体验让我见识了前所未有的迭代速度。大量工具、概念、理念如雨后春笋般涌现，又快速消失，整个产业的更新频率令人咋舌。几乎每隔几周就有新模型发布、新功能上线，或者全新产品横空出世。作为开发者，有时会疲于追赶这种变化节奏——刚熟悉一个工具，它就被超越或被抄袭了🤡，说不定另一个工具已经更好用了。不过，快速迭代也有好处，意味着我们能更快获得强大功能和更好体验。以 Xcode 版本的 Copilot 为例，短短几周内就从简单的代码补全进化到支持上下文理解、导入文件代码图片、Agent Mode、代码 Review 等功能。我每隔几天打开都会发现新功能，从未见过如此迅猛的软件迭代。从这个角度看，各家厂商确实在用心抢夺用户。

### 看得懂但是写不出

习惯了用 AI 写不熟悉语言的代码后，我经常陷入"看得懂但写不出"的尴尬境地。就像在做代码阅读理解题，我能快速理解 AI 生成的代码逻辑和实现思路，但一旦让我从零开始手写同样功能，就会磕磕绊绊，经常想不起具体的语法细节和 API 调用方式。这种依赖让我开始思考一个问题：会用 AI 写代码和修 bug，到底算不算真正会写代码？对于本就不熟悉的语言，边 vibe coding 边学，究竟是在积累真正的编程经验，还是只是在学"回"字的四种写法🫘？

### 锻炼表达能力

AI 编程让表达能力的重要性前所未有地凸显出来。想象一下日常对话中的困惑场景：对方说了一大堆话，但重点和诉求不明确，你听得云里雾里。现在，AI 就像是最严格的表达能力考官，同样的功能需求，不同的表达方式会产生截然不同的结果。表达不够清晰时，AI 只能靠猜测你的意图——猜对了皆大欢喜，猜错了就会生成逻辑错误的代码。更糟的是，这些潜在错误可能悄无声息地埋在项目中，成为未来的定时炸弹💣。常说某某模型比某某模型厉害，某某模型最近降智了等等这种说法，我认为这里的厉害比较，是模型的推断和表达能力的综合体现，随着技术进步，我想总有一天 AI 可以更精准的猜出我表达中漏掉的内容，以及更准确的理解我描述的需求，但至少在短期内，AI 还没法学会读心术，所以在描述需求和编写文档这些关键环节上，我们必须认真对待。

### 不想收拾残局症

有的时候把需求 vibe 了个七七八八，看起来已经很接近理想状态了，但总有那么一些小问题和小细节还需要改进——可能是一个按钮的位置稍微偏了点，或者某个边界条件没有处理好，又或者代码风格不够统一。这时候问题就来了：AI 就是完成不了那最后几步路，来回修改好几次也没有太大改进，就像是到了一个看得见终点却怎么也跨不过去的门槛。如果这时候要让我自己上手收拾残局，说实话心理上是有点抗拒的——看着满屏幕 AI vibe 出来的代码，光是理解这些代码的逻辑就需要花不少时间。就像是要去整理别人的房间一样，即使你明知东西都在那里，但要搞清楚每样东西为什么放在那个位置，还是需要一番功夫的。

## 进入框架

由于以上体会，让我认识到由 AI 在完成一个超级大任务的时候，还是会有各种各样的问题，而正常人不会或者说无法去看几千行 vc 出来的变更。所以目前来说，在使用 AI 的时候，我认为还是需要在自己的脑子里有一个大概的框架，让 AI 在框架里完成一个又一个的模块化任务，这样分配工作更加合理也更加可控，让流程更加高效。

### 拆分任务

人类有认知负荷的上限，如果你让我把大象放进冰箱，我肯定万般推脱，说太复杂干不了，这任务听起来就不可能做到🤯。但如果给我一个说明书，写着：把大象放进冰箱只需要3️⃣步：第一步开冰箱门，第二步把大象装进去，第三步关冰箱门，那我真的会试试，不管实际操作会遇到什么问题，但至少心理上没那么抗拒了。给 AI 布置任务也是同样道理。把"实现用户管理系统"这样的大型任务拆分成"设计数据库表结构"、"实现用户注册接口"、"添加权限验证"等具体细小的子任务，AI 的表现会好很多。如果给每个小任务都规定明确的输入输出格式和边界，那 AI 会更容易理解和执行。

更妙的是，这种拆分工作本身也不需要我们亲自动手，推断和规划正是 LLM 最擅长的事情。你可以先问 AI："我想实现一个用户管理系统，请帮我把这个需求拆分成具体的开发步骤。"AI 会给出一个详细的任务清单，然后你再逐个让它完成。这样既提高了效率，又能让开发者对整个需求有更深入的思考和把控。Claude Code 的 Plan Mode 可以用 opus 模型来规划，而用更便宜的模型来写代码，值得一试。

这个过程可以总结成一份任务相关的开发大纲，保存在项目文件夹里作为参考，之后即使你失去了第一次总结大纲的上下文，后面也可以利用这份大纲让 AI 快速地“想起来”。有了清晰的路线图，后续的开发就像按图索骥，比直接跟 AI 说：你去帮我把那个东西弄一下，效果好上不少（牛马无法直接被替代的又一铁证）。Claude Code 的 Subagent 很适合做这类规划、总结、验证、测试的工作，还能把生成大纲（或者是别的功能）和实际编码的上下文分开处理，避免占用上下文。

### 新版 Talk is cheap, show me your code

在 AI 时代，人们常说"Code is cheap, show me your talk"😂，这句话表达的核心观点是：代码生成在 AI 时代已经变得轻松简单，反而是如何精确地向 AI 描述需求、表达想法变得更加重要和具有挑战性。然而，在我的实际使用体验中，有时候与其费尽心思向 AI 描述你的需求，不如直接提供具体的代码示例或相关实现。这正是为什么各种 AI 工具的 Agent 功能越来越强大的原因——它们能够更好地理解和学习具体的代码模式。因此，如果你希望 AI 非精确、但有指向性地实现某个功能，我建议尝试以下方法：

- 直接复制网页上（或者别的地方）的完整内容作为参考，不用担心冗余
- 使用 F12 开发者工具复制目标功能的 HTML 或相关 JavaScript 代码
- 从 GitHub 上找到类似的实现作为示例
- 用不止一个 AI 工具来生成代码，并相互审查比较

通过提供这些具体的代码参考，AI 能够更准确地理解你的需求，从而生成更符合预期的结果。

## 最后





























