# [译] Swift | 内存安全

一般来说，Swift 会阻止代码中的不安全行为。例如，Swift 会保证变量在被使用前已经初始化，在释放某变量后其内存也会变得不可访问，以及检查数组索引是否存在越界错误。

Swift 还通过要求修改内存中位置的代码具有对该内存的独占访问权，来确保对同一内存区域的多重访问不会产生冲突。由于 Swift 会自动管理内存，因此大多数时候你根本不需要考虑内存访问的问题。然而，了解什么地方会有潜在的内存冲突发生也是很重要的，这样你就可以避免写出对内存访问有冲突的代码。如果你的代码中确实包含冲突，则会出现编译时错误或运行时错误。

> 译自 [Swift 官方文档](https://docs.swift.org/swift-book/LanguageGuide/MemorySafety.html)，是从 [老司机周报 #130](https://juejin.im/post/6877746452706099214) 中看到的这一篇，着实解答了我的一些疑惑🎯。

## 理解关于内存的访问冲突

当你执行设置变量的值、将参数传递给函数之类的代码时，访问内存这件事情会就发生。举个例子，以下代码包含了一个读取操作和一个访问操作：

```swift
// A write access to the memory where one is stored.
var one = 1

// A read access from the memory where one is stored.
print("We're number \(one)!")
```

当不同部分的代码试图同时访问同一块内存时，可能会发生内存冲突访问。 同时访问同一块内存可能会导致不可预测或不一致的行为。 在 Swift 中，有多种方法可以实现在跨越好几行代码的过程下修改某个值，这导致可以实现在修改自身的过程中去尝试访问自己的值。

现在通过一个相似的问题来更好地帮助你理解这种冲突，例如你现在要在一张纸上更新你的购物预算清单。更新这张预算清单分为两个步骤：1.你需要添加商品的名称和价格，2.你需要更改总价来匹配你更新后的账单。在这个更新步骤的前后，你都可以从账单中正确的读取任何数据，如下图所示。

![memory_shopping](resources/memory_shopping.png)

当你往清单中添加商品时，清单处于一个临时的、无效的状态，因为这时总价还没有被更新、还不能反映那些新加的商品。所以当你在添加商品的过程中，读取总价格的话，会给你一个错误的答案。

这个例子同样也展示了在解决冲突访问时你可能会遇到的问题：不一样解决冲突方式会带来不一样的答案，要知道哪个答案是正确的通常来说没有那么显而易见。在这个例子中，主要看你是想要原来的总价格还是更新后的总价格，$5 和 $320 都可能是正确答案。也就是说，在你解决冲突访问之前，你得先要搞清楚你要的是什么。

> 注意
>
> 如果你是在编写有关并发或多线程的代码，那么内存访问冲突可能是一个常见的问题。但要注意的是，我们在这讨论的冲突访问是可能发生在单线程上，并且不涉及并发或多线程代码。
>
> 如果你在单线程中对内存的访问存在冲突，Swift 会确保在编译时或运行时报错。对于多线程代码，请使用  Thread Sanitizer 来检测多线程的冲突访问。

## 冲突访问的特征

在冲突访问的时候，有三个访问的特征值得注意：1.这个访问操作是读还是写，2.访问的时常，3.具体访问的位置。具体来说，如果你有两个满足了以下所有条件的访问操作，那么他们是会发生冲突的：

* 他们之中至少一个是写入操作或非原子（nonatomic）操作。
* 他们访问了内存中的相同位置。
* 它们的持续时间是有重叠的。

通常来说，一个读取操作和一个写入操作的区别是很明显的：一个写入操作会改变内存中的位置，但读取操作不会。内存中的位置是指要访问的内容，例如：变量、常量或属性。内存访问可以是瞬时的，也可以是维持一段时间的。

如果你的一个操作仅使用了 C 原子（atomic）操作，则该操作是原子操作，否则就是非原子的。有关这些功能，详见 stdatomic（3）手册页。

如果你的某个操作在开始之后和结束之前都无法运行其他代码，那么这个操作就是一个瞬时操作。从本质上来说，两个瞬时操作是不能在同一时间发生的。并且，大多数内存访问操作都是瞬时的。举个例子，以下代码中读取和写入操作都是瞬时的：

```swift
func oneMore(than number: Int) -> Int {
    return number + 1
}

var myNumber = 1
myNumber = oneMore(than: myNumber)
print(myNumber)
// Prints "2"
```



















